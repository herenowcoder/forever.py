#!/usr/bin/env python
#
# (c) 2012 Wojciech Kaczmarek <frk@kofeina.net>. All rights reserved.
# Released under the BSD 2-clause license - see this for details:
# http://github.com/herenowcoder/forever/blob/master/LICENSE

usage = """
    ./forever options.. command command_args
    ./forever options.. 'command1 && command2'

    options:
        -1             run command on start
        -0             don't run command on start
        -f 'masks'     masks of files to be monitored, QUOTED !!
        -p preset      use configuration preset
        -v             print configuration before running
        -n             print configuration then exit
        -h             print this help and exit
"""

import os, select
from sys import argv
from glob import glob
from time import sleep

defaults = [
    [['tnt', 'motion'],
     { 'masks':
       ['Rakefile', 'resources/*.storyboard'] +
       [dir + "/*.rb" for dir in
        ['app', 'app/[0-9]*', 'app/[0-9]*/*', 'spec']],
       'run_on_start': True
      }],
    [['rails'],
     { 'masks': 
       ['Rakefile'] +
       [dir + "/*.*rb" for dir in
        ['app/views/*', 'app/models', 'app/controllers', 'test/*']] +
       [dir + "/*.yml" for dir in ['test/fixtures']],
       'run_on_start': True
       }],
    [['sexit'],
     { 'masks': ['*.py', '*.pl'],
       'run_on_start': True
       }],
]

def cwd_proj():
    return os.getcwd().split('/')[-1]

def default(proj=None):
    proj = proj or cwd_proj()
    d = [d for [names,d] in defaults if proj in names]
    return d[0] if d else {}

def expand_masks(masks):
    return [x for sublist in [glob(mask) for mask in masks] for x in sublist]

def run_command(cmd):
    os.system(cmd)
    print "\n>>>> done <<<<"

def eat_options(args):
    global run_on_start, verbose, dry_run, masks, preset
    
    if args and args[0].startswith('-'):
        if args[0] == '-0':
            run_on_start = False
        elif args[0] == '-1':
            run_on_start = True
        elif args[0] == '-v':
            verbose = True
        elif args[0] == '-n':
            dry_run = True
        elif args[0] == '-h':
            print usage; exit()
        elif args[0] == '-f':
            masks = args[1].split(' ')
            return eat_options(args[2:])
        elif args[0] == '-p':
            preset = args[1]
            return eat_options(args[2:])
        return eat_options(args[1:])
    else: return args

masks = None
run_on_start = None
verbose = False
dry_run = False
preset = None
args = eat_options(argv[1:])
masks = masks or default(preset).get('masks') or []
if run_on_start is None:
    default_run_on_start = default(preset).get('run_on_start')
    if default_run_on_start is not None: 
        run_on_start = default_run_on_start
    else:
        run_on_start = True
files = expand_masks(masks)
cmd = ' '.join(args)

if verbose or dry_run:
    print '* default:', preset or cwd_proj(), default(preset)
    print '* masks:', masks
    print '* files:', files
    print '* run_on_start:', run_on_start
    print '* cmd:', cmd
if dry_run: exit()

if not files:
    print "gimme some files"; exit(2)

if run_on_start and len(cmd):
    run_command(cmd)

def add_file(f):
  global filemap, events
  fd = os.open(f, os.O_RDONLY)
  filemap[fd] = f
  ev = select.kevent(fd,
    filter=select.KQ_FILTER_VNODE,
    flags=select.KQ_EV_ADD | select.KQ_EV_ENABLE | select.KQ_EV_CLEAR,
    fflags=select.KQ_NOTE_WRITE | select.KQ_NOTE_DELETE)
  events.append(ev)

kq = select.kqueue()
events = []
filemap = {}
for f in files:
  add_file(f)

kq.control(events,0)

while True:
    new_events = kq.control([], len(files))
    for ev in new_events:
      if ev.filter == select.KQ_FILTER_VNODE:
        if ev.fflags & select.KQ_NOTE_DELETE:
          # todo: remove events of deleted files
          sleep(0.1)
          add_file(filemap[ev.ident])
          kq.control(events,0)

    print "* detected change, %s" % \
      (("running %s" %cmd) if len(cmd) else "but no command given")
    if len(cmd): run_command(cmd)
